## Goland

#### 内存逃逸

堆分配昂贵，栈分配廉价

堆需要垃圾回收

Goland会校验变量的生命周期是否在运行时完全可知，可知在栈上分配，否则在堆上

**常见逃逸情况：**

- 发送指针或带有指针的值到channel
- 切片上存储指针或带指针的值
- slice背后的数组被重新分配
  - 最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配
- 在 interface 类型上调用方法
- 指针指向的数据都是再堆上分配的

#### goland传指针和传值

go只有值传递，传指针也是一个指向同一个地方的指针副本

#### new和make区别

new只分配，不初始化

make既分配内存又初始化内存（仅用来分配并初始化slice、map、chan）

#### Goland的GC

三色标记法

- 触发时机
  - 阈值：默认内存扩大一倍
  - 定时：默认两分钟进行GC
  - 手动：执行runtime.GC

#### GMP

G：协程

M：线程

P：处理器

#### Channel

缓存区（环状链表）

记录有开始和结束时的下标

互斥锁

接收和发送的协程队列（双向链表）