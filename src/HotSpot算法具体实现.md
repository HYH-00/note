[TOC]

# HotSpot算法具体实现

## 根节点枚举

可达性算法分析中占用时间最长的查找引用链过程可以与用户进程并发实现，但是所有的收集器在根节点枚举这个步骤必须是要暂停用户线程的

`因为主流的Java虚拟机都是用准确式的垃圾收集，所以不需要一个不漏地检查完所有执行上下文和全局的引用位置，HotSpot使用OopMap的数据结构来直接得到哪些地方存放引用。`

类加载完成后，HotSpot就会把对象内什么偏移量是什么类型的数据计算出来，在即时编译时也会在特定地方记录哪些位置是引用

## 安全点

在OopMap的帮助下，HotSpot可以快速准确完成GC Roots的枚举，但是导致OopMap变化的因素非常多，为每一条指令产生一个OopMap，需要大量的空间

OopMap太少会让收集器等待的时间变多，OopMap太多会让空间占用大

`不过进程就只能在安全点处停顿，只要保证引用变化在GC停顿前就可以`

垃圾收集时就需要让所有的进程跑到安全点停顿下来

- 抢先式中断

    中断不需要线程代码主动配置，当垃圾收集发生时，中断所有线程，如果发现有线程不在安全点上，则恢复线程执行，让他一会再执行中断，直到跑到安全点上

- 主动式中断

    当需要中断时不对线程进行操作，而是简单的设置一个标志位，各个线程执行时会不断轮询这个标志，一旦发现这个标志位为真时就在最近的安全点上主动挂起，而这个标志位和安全点是重合的

    因为轮询会频繁出现，所以需要足够高效，HotSpot采用内存保户陷阱的方式把轮询操作精简到一条汇编指令的程度

    `当需要暂停线程时把指定页设置为不可读，那执行到该位置的时候会产生自陷异常信号，然后在预先注册的异常处挂起线程`

## 安全区域

当用户线程处于Sleep或者Blocked状态时，线程无法响应虚拟机的中断请求，这个时候不可能等待线程被激活才进行垃圾回收

可以看成是扩大了安全点，在安全区域不会发生引用关系的变化，当用户进入安全区域时会告诉虚拟机自己进入了安全区域，这样在垃圾收集的时候虚拟机就不必管处于安全区域的线程，而线程出安全区域需要判断是否已经完成了根节点枚举

## 记忆集与卡表

记忆集也就是用于记录跨代信息的数据结构，避免将整个老年代加入扫描范围

因为只需要知道那些地方有跨代引用，不需要详细信息，所以可以使用粗犷的记录粒度

- 字长精度：每个记录精确到一个字长
- 对象精度：每个记录精确到一个对象，该对象里有跨代指针
- 卡精度：每个记录精确到一块内存区域

这种卡精度就是用一种称为卡表的方式去实现记忆集，也是最常用的记忆集实现形式

## 写屏障

分写前屏障和写后屏障，也就是在写操作的前后进行标记操作

这样可能会导致伪共享

伪共享可以用有条件的写屏障解决，当卡表元素未被标记过时才进行变脏操作

## 并发可达性

用三色标记进行推导计算

和用户线程并行工作时会产生有垃圾没清理和对象消失

也就是该删的没删，不该删的删了

垃圾没清其实是可以容忍的，但是对象消失就比较严重

有增量更新和原始快照两种方式，分别破坏对象消失的两个要素

- 赋值器插入了黑色对象到白色对象的引用
- 赋值器删除了所有灰色对象到该白色对象的引用