# Mysql——interview

## 分页查询

```sql
SELECT ... FROM ... WHERE ... ORDER BY ... LIMIT ...
```

使用索引

```sql
SELECT * FROM articles WHERE category_id = 123 ORDER BY id LIMIT 50, 10
```

子查询

```sql
SELECT * FROM articles WHERE  id >=
 (SELECT id FROM articles  WHERE category_id = 123 ORDER BY id LIMIT 10000, 1) LIMIT 10
```

join分页

```sql
SELECT * FROM `content` AS t1 
JOIN (SELECT id FROM `content` ORDER BY id desc LIMIT ".($page-1)*$pagesize.", 1) AS t2 
WHERE t1.id <= t2.id ORDER BY t1.id desc LIMIT $pagesize; 
```

join和子查询分页基本一致

```
子查询是在索引上完成的，而普通的查询时在数据文件上完成的，通常来说，索引文件要比数据文件小得多，所以操作起来也会更有效率
```

## 索引

### 索引类别

**FULLTEXT**全文索引

**HASH**

- Hash 索引仅仅能满足"=","IN"和"<=>"查询，不能使用范围查询。 
- Hash 索引无法被用来避免数据的排序操作
- Hash 索引不能利用部分索引键查询
- Hash 索引在任何时候都不能避免表扫描
- Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。 

**BTREE**

### 索引的数据结构（B+Tree）

- 非叶子节点不存储数据，只存储索引
- 叶子节点包含所有索引字段
- 叶子节点用指针连接，提高区间访问性能

#### 索引目的

提高查询效率

### 索引原理

通过不断的缩小想要获得数据的范围来筛选出最终想要的结果

### 磁盘IO与预读

磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分

B+树每一个节点就是一个磁盘块，读取时进行一次IO

- IO数取绝与树的高度

### B+树对于B树的优势

- B+跟B树不同B+树的**非叶子**节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个**非叶子**节点所能保存的关键字大大增加，降低磁盘IO

- B+**树的层级更少**：相较于B树B+每个**非叶子**节点存储的关键字数更多，树的层级更少所以查询数据更快
- B+**树查询速度更稳定**：B+所有关键字数据地址都存在**叶子**节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;
- B+**树天然具备排序功能：**B+树所有的**叶子**节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高
- B+**树全节点遍历更快：**B+树遍历整棵树只需要遍历所有的**叶子**节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描

### B+树对比Hash

- hash速度远快于B+树

但是hash存在极个比较关键的问题

- hash只能精确定位到一条数据，只能用in和==，不能用比较操作
- hash不好排序
- hash不能用部分索引
- 大量hash相等情况并不一定比B+树块

### B+树对比二叉树

- 降低了树高度，减少磁盘IO

## 事务

### 什么是事务

**事务就是为了保证一组数据库操作，要么全部成功，要么全部失败**

### 事务的四大特性ACID

- A——原子性
- C——一致性
- I——隔离性
- D——持久性

C是目的，AID是手段，通过AID保证一致性

```
一致性也就是符合约束，通过AID避免不符合约束的操作
```

### 产生的问题

- 脏读
- 不可重复读
- 幻读

### 数据库隔离级别

- 读未提交

    - 读锁、写锁都在一个原子操作（如select、insert等）完成后立即释放

- 读已提交——避免脏读

    - 读锁仍然在一个原子操作完成后立即释放；写锁从写操作开始持有，事务提交后释放

- 可重复读——避免脏读和不可重复读

    - 悲观策略（悲观锁）：串行化
        - 放弃并发、串行执行，当然不存在任何问题
        - 读锁、写锁都从读、写操作开始持有，事务提交后释放
    - 乐观策略（乐观锁）：多版本 + 冲突检测
        - 事务开始时持有当前数据的快照，读写均不冲突，提交时检测修改的快照与当前数据是否冲突

- 可序列化——避免脏读、不可重复读和幻读

    - 从各操作开始前持有读锁、写锁、范围锁，直到事务提交后释放

    

`大多数数据库的默认隔离级别都是Read Committed，但MySQL不是。`

### 数据库三大范式

- 第一范式：确保每列保持原子性
    - 第二范式：确保表中的每列都与主键相关
- 第三范式：确保每列都和主键列直接相关,而不是间接相关

### 引擎

#### MyISAM

优势：访问速度快

适用场景：对事务的完整性没有要求，或以select、insert为主的应用基本都可以选用MYISAM

#### InnoDB

优势：提供了具有提交（Commit）、回滚（Rollback）、崩溃恢复能力的事务安全，支持外键

缺点：相比较于MyISAM，写的处理效率差一点，并且会占用更多的磁盘空间来存储数据和索引

适用场景：如果应用对事务的完整性有较高的要求，在并发条件下要求数据的一致性，数据操作中包含读、插入、删除、更新，那InnoDB是最好的选择

## 死锁

### 产生条件

互斥条件：一个资源每次只能被一个进程使用

请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放

不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺

循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系

### 预防和消除

也要防止进程在处于等待状态的情况下占用资源,在系统运行过程中，对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，若分配后系统可能发生死锁，则不予分配，否则予以分配 。因此，对资源的分配要给予合理的规划。