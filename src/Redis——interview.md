# Redis——interview

## 基本数据类型

- String
    -  定义简单动态字符串SDS作为 Redis的默认字符串表示
- List
    - ziplist/双端链表->2.0**quicklist**
- Hash
    - ziplist/hashtable
- Set
    - intset/hashtable
- ZSet
    - ziplist /skiplist

## 特殊数据类型

- Geospatial

- Hyperloglog

- Bitmaps

## 事务

Redis事务的本质：一组命令的集合！一个事务中的所有命令都会被序列化

一次性、顺序性、排他性，执行一系列命令

`Redis单条命令保持原子性，但是事务不保证原子性`

`Redis没有事务的隔离级别`

## 主从同步

### 主从同步分两个步骤：同步和命令传播

同步：将从服务器的数据库状态更新成主服务器当前的数据库状态

命令传播：当主服务器数据库状态被修改后，导致主从服务器数据库状态不一致，此时需要让主从数据同步到一致的过程

sync命令

<img src="https://pic1.zhimg.com/80/v2-b328e58c4cab8d7dbdf1ac64814ebcfc_720w.jpg" alt="img" style="zoom:67%;" />

### psync

2.8开始使用psync：具有完整重同步和部分重同步两种模式

- 完整重同步：用于初次复制情况，执行过程同 sync，在这不赘述了

- 部分重同步：用于断线后重复制情况，如果满足一定条件，主服务器只需要将断线期间执行的写命令发送给从服务器即可

#### 部分重同步条件

- 主从服务器的复制偏移量
    - 执行复制的主从服务器都会维护各自的复制偏移量
        - 主服务器每次向从服务器传播 n 个字节数据时，都会将自己的复制偏移量加 n。
        - 从服务器接受主服务器传来的数据时，也会将自己的复制偏移量加 n
- 主服务器的积压缓冲区
    - 复制积压缓冲区是一个固定长度，先进先出的队列，默认 1MB
    - 当主服务器进行命令传播时，不仅会将命令发送给从服务器，还会发送给这个缓冲区。
    - 若复制积压缓冲区存在从服务器的复制偏移量 + 1 后的数据，则进行部分重同步，否则进行完整重同步
- 服务器的运行 id
    - 运行 id 是在进行初次复制时，主服务器将会将自己的运行 id 发送给从服务器，让其保存起来
    - 若当前服务器的运行 id 与之相同，说明从服务器断线前复制的服务器就是当前服务器，主服务器可以尝试执行部分同步；若不同则说明从服务器断线前复制的服务器不是当前服务器，主服务器直接执行完整重同步

### 心跳检测

主从服务器就会进入命令传播阶段，此时从服务器会以每秒 1 次的频率，向主服务器发送命令：`REPLCONF ACK <replication_offset>` 其中 replication_offset 是从服务器当前的复制偏移量

发送这个命令主要有三个作用：

- 检测主从服务器的网络状态
- 辅助实现 min-slaves 选项
- 检测命令丢失（若丢失，主服务器会将丢失的写命令重新发给从服务器）

### 作用

数据冗余：主从复制实习了数据的热备份，是持久化之外的一种数据冗余方式

故障恢复：当主节点出现问题时，可以由从节点提供服务，相当于一个服务的冗余

负载均衡：在主从复制的基础上实现读写分离

高可用（集群）基石：是哨兵和集群能够实施的基础

## Redis主从数据不一致情况

**常见的数据库集群架构**

一主多从，主从同步，读写分离

### 数据不一致解决方案

#### 忽略

业务能接受，最推崇此法

#### 强制读主

使用一个高可用主库提供数据库服务

读和写都落到主库上

采用缓存来提升系统读性能

#### 选择性读主

用一个缓存记录必须读主的数据

## Redis与MySQL的区别

Redis：内存数据库，访问数据的速度快，更易丢失

Mysql：无论数据还是索引都存放在硬盘中。到要使用的时候才交换到内存中。能够处理远超过内存总量的数据。

持久化是使用 rdb 方式或者 aof 方式

## Redis持久化

### RDB

在指定时间间隔内将内存中的数据集快照写入磁盘，Snapshot快照，恢复时将快照文件直接读到内存

报错快照是由子进行完成，将内存写入临时的edb文件，快照写入完成后覆盖原先的快照文件

`如果进行大规模的数据恢复或者对数据完整性要求不高，edb比aof更高效，缺点的可能丢失最后一次持久化的数据`

#### 优点

- 适合大规模的数据恢复
- 对数据完整性要求不高

#### 缺点

- 需要一定的时间间隔，如果意外宕机，最后一次修改数据就丢失
- fork进程，会占用一定内存空间

### AOF

以日志的形式记录每一个写的操作，将所有执行过的指令记录下来（读操作不记录）

redis重启的话会根据日志文件的内容将写指令从前到后执行一遍完成数据恢复

#### 优点

- 每次修改都同步，文件完整性会更加好
- 每秒同步一次，可能丢失数据
- 从不同步效率更高

#### 缺点

- 相对于数据文件来说，aof远大于rdb，所以aof比rdb慢

#### Rewrite机制

当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集

##### 原理

会fork出一条新进程来将文件重写

##### 触发机制

 Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发

## 哨兵模式

> 自动选举老大

监控后台主机是否故障，故障了根据投票数自动将票数最高的从机变为主机

通常哨兵需要集群，防止哨兵宕机

`当一个哨兵模式发现主机不可用，称为主观下线，当多数哨兵都发现不可用时会进行投票选举主机，称为客观下线`

主机回来只能归并到新的主机下，当作从机

### 优点

- 哨兵集群，基于主从复制模式，所有的主从配置优点，全有
- 主从可以切换，故障可以转移，可用性更好
- 哨兵模式是主从模式的升级，手动到自动

### 缺点

- 不好在线扩容，集群容量达到上限在线扩容就很麻烦
- 哨兵模式配置复杂

## Redis缓存穿透和雪崩

### 缓存穿透

redis内存数据库没有，缓存未命中，会向持久层数据库请求，当请求很多的时候会导致持久层数据库崩溃

#### 解决方案

**布隆过滤器**

对可以查询的参数以hash形式存储，在控制层校验，不符合则丢弃，避免了对底层存储系统的压力

**缓存空对象**

缓存不命中，返回一个空值，空值也会被储存起来

### 缓存击穿

很热的key在过期后同时请求数据库

#### 解决方案

**设置热点数据永不过期**

**加互斥锁**

分布式锁，每一个key只有一个进程能够查询

### 缓存雪崩

某一个时间段，缓存集中过期失效，Redis宕机

#### 解决方案

**redis高可用（异地多活）**

**限流降级**

**数据预热**

## Mysql和Redis的一致性

### 前后双删

读的顺序是先读缓存，后读数据库

写的顺序是先写数据库，然后写缓存

每次更新了相关的数据，都要把该缓存清理掉

为了避免极端条件下造成的缓存与数据库之间的数据不一致，缓存需要设置一个失效时间。时间到了，缓存自动被清理，达到缓存和数据库数据的“最终一致性”

## Redis过期删除

### 定时删除

在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作

- 优点
    - 通过使用定时器，定时删除策略可以保证过期键会尽可能快地被删除，并释放过期键所占用的内存
- 缺点
    - 在过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分CPU时间

### 惰性删除

放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键

- 优点
    - 程序只会在取出键时才对键进行过期检查，这可以保证删除过期键的操作只会在非做不可的情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会再删除其他无关的过期键上花费任何CPU时间
- 缺点
    - 如果一个键已经过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，它所占用的内存就不会释放

### 定期删除

每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多个过期键，以及要检查多少个数据库，则由算法决定

- 优点
- 缺点

定期删除怎么做的？（服务器事件循环）

