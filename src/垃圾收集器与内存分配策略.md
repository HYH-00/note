[TOC]

# 垃圾收集器与内存分配策略

## 判断实例是否"已死"

### 计数算法

每一个实例都加入一个应用计数器，每被引用一次就计数+1，引用失效时就-1，当一个实例计数为0的时候说明实例死了，也就是不能被使用了。

#### 优点

`原理简单，判断效率高`

大多数情况下都是一个很不错的算法，也有很多比较著名的案例：微软的COM、FlashPlayer、Python

#### 缺点

看似简单的算法需要很多例外的情况要考虑，必须配合大量额外处理才能保证正确的工作，比如单纯的计数算法就很难解决对象之间的循环引用问题

### 可达性分析算法

通过一系列称为"GC Roots"的根对象作为起始点集，根据引用关系向下搜索，搜索走过的路径为引用链

可以作为GC Roots的对象有：在虚拟机栈中引用的对象、在方法区中静态属性引用的对象、在方法区中常量引用的对象、在本地方法中JNI引用的对象、Java虚拟机内部的引用、所有被同步锁持有的对象、反映虚拟机内部情况的JMXBean

处理这些还会有一些临时对象加入

<img src="https://i.loli.net/2021/01/26/uxcDAI2OYfigorz.png" alt="未命名文件" style="zoom: 50%;" />

### 引用

#### 强引用

指的是引用赋值，比如说Object obj=new Object()；

`这种情况下永远不会进行回收`

#### 软引用

`描述一些还有用，但是非必须的对象，在系统将要发生内存溢出异常前会把这些对象纳入回收范围进行第二次回收`

SoftReference类来实现软引用

#### 弱引用

`弱引用比软引用更弱一点，只能生存到下次垃圾收集为止`

WeakReference

#### 虚引用

`最弱的一种引用，唯一的作业是为了能在这个对象被收集器回收时得到一个通知`

### 回收时的自救

即使在可达性分析算法中判定不可达也不是"非死不可"的，暂时还处于缓刑阶段

在一轮可达性分析后，不可达的对象会被标记，然后进行一次筛选，如果覆盖了finalize且这方法没有被执行过会执行这个方法

会被放在一个叫F-Query的低优先级的队列中，只保证方法执行，不保证方法执行完毕

如果执行这个方法后成功建立了引用链就不必清理它

### 回收方法区

主要是对废弃的常量和不再被使用的类进行回收

## 垃圾收集算法

从如何判断对象消亡的角度出发，可以分成引用计数式垃圾收集和追踪式垃圾收集，也常被称作直接垃圾收集和间接垃圾收集

### 分代收集理论

#### 分代理论的的三个假说

- 弱分代假说：绝大多数对象都是朝生夕灭的
- 强分代假说：熬过越多次垃圾回收的对象越难被回收              
- 跨代引用假说：跨代引用仅占同代引用的极少部分

弱分代说和强分代说考虑将Java堆中的对象分配到不同的区域中进存储，也就是分成新生代和老年代

`扫描新生代可以有更高的垃圾回收效率`

`用较低的频率执行老年代的垃圾收集`

兼顾了垃圾回收的时间开销和空间消耗

跨代引用假说是对于垃圾回收时的跨代引用现象提出的

`考虑在新生代中开辟一个全局的数据结构，存放老年代中哪些部分有跨代引用，新生代清理时就不必扫描全部的老年代`55

### 标记——清除算法

> 分标记和清除两个部分，标记是将存活和死亡的对象区分开来（可以标记死亡也可以标记存活）

**缺点**

- 当死亡的对象比较多的话，大量的标记和清除动作，效率随数量的增长降低
- 回收后会产生大量的碎片

### 标记——赋值算法

> 内存只使用一半的内存，当清理的时候将已经存活的对象按顺序复制到另一个部分，再清空这个部分的空间

**缺点**

- 只使用了一半的内存空间，空间耗费巨大
- 当存活的对象很多的时候复制操作消耗太大

`Java虚拟机大都采用这个方式回收新生代`

IBM公司曾经有一项研究对新生代的"朝生夕灭"有更量化的诠释——新生代有98%都熬不过第一轮收集，因此不需要1：1划分新生代和老年代

#### Appel式回收

将新生代的空间分成一个Eden和两个Survivor，比例为8：1，当使用时只使用一个Eden和一个Survicor，垃圾回收时将存活的对象复制到另一个Survivor中

这种方式使用率为90%，但是当一个Survivor存放不到时就需要将多余的由老年代分担

### 标记——整理算法

标记赋值算法在对象存活较多的时候就需要进行大量的复制操作效率会降低，而且对于另一半空间不足的情况，还需要额外的空间来担保，对于老年代来说是很繁重的负担

虽然标记整理算法对空间的移动会比较多，因为内存空间的访问比垃圾回收更加频繁，所以标记整理算法的吞吐量会更高，但是因为移动时需要暂停用户的应用程序才能进行

`标记——清除算法：会产生大量碎片空间，使空间分配更复杂，延迟低`

`标记——整理算法：空间回收的时候更加复杂，吞吐量高`

HotSpot虚拟机中关注吞吐量的Parallel Scavenge收集器是基于标记整理算法实现的，而关注延迟的CMS收集器是基于标记清理算法实现

可以采用两种方式结合使用的方式：平时多数采用标记清理算法，暂时容忍碎片存在，当碎片比较多的时候采用标记整理算法收集一次，CMS收集器就是采用这种方式

