# Java——interview

## 集合

### List

#### ArrayList

- 数组实现，查询效率高，增删效率低
- 初始10，每次扩容变为原来的1.5倍
- 以新的容量建一个原数组的拷贝，修改原数组，指向这个新数组，原数组被抛弃

- 初始10，扩容1.5，最大int-8

#### LinkedList

- 双向链表实现，查询效率低，增删效率高
- 因为是双向链表，可以作为栈，队列，双向队列

#### Vector

- 与ArrayList类似，保证并发状态的线程安全，是重量级组件
- 扩容到1.5或2倍

### Set

#### HashSet

- 底层包装了HashMap实现

#### LinkedHashSet

- HashSet的一个子类

- 用一个链表来维护元素的插入顺序

#### TreeSet

- 底层用TreeMap实现
- 本质上是一个红黑树原理
- 因为它是排序了的，所以相对HashSet来说，TreeSet提供了一些额外的按排序位置访问元素的方法

### Map

#### HashMap

- 数组+（链表，红黑树）
- 初始容量大小16，扩容因子为0.75，扩展为原来2倍
- 因子过小造成资源的浪费，过大会使get,put操作的碰撞几率增加

- 大小为2的幂次
    - 计算元素该存放的位置的时候，用到的算法是将元素的hashcode与当前map长度-1进行与运算
- put时候校验key是否为null，为null的话value就为0，不会校验value

#### Hashtable

- 线程安全
- 加锁包含synchronized
- 判断value是否为null，并且不对key进行判断，计算hashcode会抛出异常

#### TreeMap

- 对key排序的Map
- 底层是红黑树

#### LinkedHashMap

- 与HashMap相比维护着一个运行于所有条目的双重链接列表。存储的数据是有序的

- 允许key和value为null，底层用双向链表

#### ConcurrentHashMap

- 高效线程安全的集合
- 分段锁技术
- 抛弃了原有的 Segment 分段锁，而采用了 `CAS + synchronized` 来保证并发安全

### Stack

- 线程安全，继承于Vector

## 字段

### volatile

- 保证可见性
    - volatile关键字会强制将修改的值立即写入主存
    - 使其他线程的缓存无效
    - 所以其他线程读取数据的时候就会从主存读取
- 禁止指令重排序
    - 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行
    - 在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行

#### 底层

- lock前缀指令，相当于一个内存屏障
    - 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成
    - 它会强制将对缓存的修改操作立即写入主存
    - 如果是写操作，它会导致其他CPU中对应的缓存行无效

### synchronized

- 修饰方法（锁定方法）
- 修饰代码块（锁代码块）
- 修饰静态方法（锁该类所有对象）
- 修饰类（锁该类所有对象）

### lock

#### 对比synchronized

- lock是一个接口，synchronized是一个Java关键字，内置实现

- synchronized自动释放锁，lock不会

- lock可以响应中断，synchronized不能

- lock可以知道有没有获得锁

- lock可以提高多个线程进行读操作的效率

- 可中断锁：lock是，synchronized不是

- 公平锁：lock可以为公平也可以非公平，synchronized只能非公平

    

### final

- 修饰类：类永远不能被继承
    - final类中的所有成员方法都会被隐式地指定为final方法
- 修饰方法：禁止子类覆盖
- 修饰变量：
    - 如果是基本数据类型，则初始化之后便不能更改
    - 如果是对象，则不能指向其他对象

### static

存放在静态存储区

- 修饰方法
    - 方便在没有创建对象的情况下使用其方法
- 修饰变量
    - 静态变量被所有对象共享，在内存中只有一个副本
- 修饰代码块
    - 在类初始化的时候只执行一次

### String/StringBuilder/StringBuffer

- String值是不可变的，每次操作会产生新的String对象

- StringBuffer线程安全
- 每次获取toString都会直接使用缓存区
- StringBuilder线程不安全（所有公开方法有synchronized）

    

## 包装类

- 声明方式不同：基本类型不适合new关键字，而包装类型需要使用new关键字来在堆中分配存储空间；
- 存储方式及位置不同：基本类型是直接将变量存储在堆栈中，而包装类型是将对象放在堆里面，然后通过引用来使用
- 初始值不同：基本类型的初始化入int为0，boolean为false，而包装类的初始值为null
- 使用方式不同，基本类型直接赋值使用就好，而包装类型在集合入collection、map时会使用到

引用比引用，比较地址

值比引用，比较值

## 其他

### 哈希碰撞

- 开放地址法
- 再哈希
- 拉链法
- 建立一个公共溢出区

### ==和equals

- 对于基本数据类型：比较值是否相等
- 对于引用数据类型：比较引用的地址是否相等

### Java面向对象的四大特征

- 抽象
- 封装
- 继承
- 多态

### 六大设计原则

- 单一职责原则
- 开闭原则
- 依赖倒转原则
- 接口隔离原则
- 迪米特法则
- 里氏替换原则

### Java同步机制

- ThreadLocal 
- synchronized
- wait
- notify
- volatile

## 并发

### 创建线程的方式

- 继承Thread
    - Java不支持多继承，继承Thread类后就不能继承其他类了；多个线程之间不能共享线程类的实例变量。没有返回值
- 实现Runnable接口
    - 还可以继承其他类； 多个线程共享同一个target对象，所以适合多个相同线程来处理同一个份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，体现了面向对象的思想
    - 没有返回值
- 实现Callable接口
    - 还可以继承其他类； 多个线程共享同一个target对象，所以适合多个相同线程来处理同一个份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，体现了面向对象的思想； FutureTask 配合可以用来获取异步执行的结果
    - 可以返回结果和抛出异常
- 线程池
    - 可缓存线程池
    - 定长线程池
    - 定期或延迟执行线程池
    - 单例线程池

### 终止线程

- 使用标志位终止线程
- stop终止线程（弃用）
    - 导致一些清理性的工作的得不到完成，如文件，数据库等的关闭
    - 导致数据得不到同步，出现数据不一致的问题
- interrupt



join：等待线程终止

getState：得到线程状态

